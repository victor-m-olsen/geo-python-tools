# -*- coding: utf-8 -*-
"""Adding_urban_to_LC-map_v2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nUeAUgOQVhafE50_aKEB6d0EZNCnlHQD
"""

# !pip install geopandas
# !pip install rasterio
# !pip install rioxarray
# !pip install matplotlib
# !pip install numpy

import rasterio
import geopandas as gpd
from rasterio import features
import numpy as np

# from google.colab import drive
# drive.mount('/content/drive')

# Loading OSM data
landuse_path = r'D:\02_Portfolios\00_Other\02_LC\02_Data\OSM\hajjah_landuse.shp'
land_use = gpd.read_file(landuse_path)

buildings_path = r'D:\02_Portfolios\00_Other\02_LC\02_Data\OSM\hajjah_buildings.shp'
buildings = gpd.read_file(buildings_path)


# Select polygons based on attributes
residential = land_use[land_use.fclass=='residential']
industrial = land_use[land_use.fclass=='industrial']
land_use = residential.append(industrial)


# Change CRS (in order to buffer) and buffering
buildings = buildings.to_crs({'init': 'epsg:32638'})
land_use = land_use.to_crs({'init': 'epsg:32638'})
buildings_buff = buildings.to_crs({'init': 'epsg:32638'})
buildings_buff['geometry'] = buildings_buff.geometry.buffer(50)

# Combinging polygons
urban = buildings_buff.append(land_use)

# Changing back CRS
urban = urban.to_crs({'init': 'epsg:4326'})

# Setting attribute for urban class in dataframe
urban['value'] = 3

### Open lc tif
lc_path = r"D:\02_Portfolios\00_Other\02_LC\03_Results\classification_result_7.tif"
lc = rasterio.open(lc_path)






### Rasterizing urban vector data

# Preparing empty tif to write urban shp into
lc_urban = r"D:\02_Portfolios\00_Other\02_LC\03_Results\urban.tif"

# Open reference tif to extract profile (metadata)
meta = lc.meta.copy() # Extracting properties from lc-tif
meta.update(compress='lzw')

with rasterio.open(lc_urban, 'w+', **meta) as out:

    out_arr = out.read(1)

    # this is where we create a generator of geom, value pairs to use in rasterizing
    shapes = ((geom,value) for geom, value in zip(urban.geometry, urban.value))

    burned = features.rasterize(shapes=shapes, fill=0, out=out_arr, transform=out.transform)
    out.write_band(1, burned)






### Conditional combination of datasets

# Converting rasterio dataframes to numpy array
lc = np.array(lc.read(1))
lc_urban = np.array(rasterio.open(lc_urban).read(1))

# Converting any existing urban land to sand - OBS: only relevant if urban has been wrongly classified!!!!!
lc = np.where(lc==3, 1, lc)

# Making boolean filter
urban_boolean = np.where(lc_urban==3, True, False)
urban_boolean = np.where(lc==7, False, urban_boolean)
urban_boolean = np.where(lc==5, False, urban_boolean)
urban_boolean = np.where(lc==4, False, urban_boolean)

# Applying boolean filter
new_lc = np.where(urban_boolean, lc_urban, lc)

# Write new_lc to tif
lc_urban_output = r"D:\02_Portfolios\00_Other\02_LC\03_Results\Flood_model_LC\hajjah_land_cover.tif"   # Preparing empty tif to write urban shp into

with rasterio.open(lc_urban_output, 'w', **meta) as dst:
    dst.write(new_lc.astype(rasterio.int32), 1)
